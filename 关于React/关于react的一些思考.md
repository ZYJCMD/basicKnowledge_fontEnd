## 关于 React 的一些思考

缘起，在阅读了一些关于 react 的一些书籍和文档后，对 React 有了一些自己的想法。
正如 React 的官方文档所讲的一样，React 的核心是“快速响应”，我们深入学习 react 的目的也应该落在于此，而不是兜兜转转忘了自己学习的初心。既然如此，我觉得可以把 react 的学习分为两个部分一个核心是 Diff 算法，一个核心是生命周期。
Diff 算法，其目的在于减少真实 DOM 操作进而提高性能，于我们大多数工程师而言，其核心不在于如何去优化算法减少空间或者时间复杂度，而在于知道了 diff 算法如何运行后，当我们写代码时，我们更能知道，当面对多种实现方式的时候，哪一种是最合适的；生命周期，是 React 给我们的钩子，也是给我们的一个角度，让我们知道页面渲染的整个发展过程是如何的，减少渲染，我们该如何去操作一些请求，其目的最终还是要落回我们的业务上去，去实现“快速响应”这一目标。

或者总的来说，就是**合适的时候做合适的渲染**

### Diff 算法

这里，不谈论 Diff 算法如何实现的，想聊聊，当我们知道了 diff 算法实现的大致流程后，我们该如何去做，当面对多种代码写法的时候，去如何优化我们的代码。
优化我们的代码，就是希望 Diff 算法执行的更快，让 JS 代码执行更少的时间，进而让我们浏览器更早的将我们修改的页面渲染出来。
根绝我们了解到的 diff 算法，主要可以分为以下几点：

1.  根据 diff 算法的设计原则，应尽量避免层级节点移动

2.  通过设置唯一 key 进行优化，尽量减少组件层级深度。因为过深的层级会加深遍历深度，带来性能问题
    _解释_：Diff 的比较层级，从高到低主要可以分为三层次：树比对，组件比对和元素比对。当涉及到 key 的时候，已经到了元素的比对，这一层级的时候节点开始对应真实的 DOM 剪裁操作。通过标记 key 的方式，React 可以直接移动 DOM 节点，且实现 DOM 节点的复用，达到提升性能的目的。为什么说需要减少组件层级的深度了，diff 算法采用深度优先的方法进行比对，当然如果层级越深，所耗费的时间也越多，性能越差，另一方面，如果嵌套太深，从我们写业务逻辑的角度来看也是颇为麻烦的。

3.  设置 shouldComponentUpdate 或者 React.pureComponent 减少 diff 次数
    _解释_：这一层级设计到 React 的组件比对层级。在 diff 算法的比对中，如果组件的 class 一致，则默认为相似的树结构，然后在进行内部的树结构比对。如果不同就直接放入补丁（patch）中。假设，有个小组件 A，在 t0 时段其父组件是 B，在 t1 时段其父组件是 C，但两个时间段，尽管组件 A 都没有变化，但按照父组件 class 不同重新渲染的原则，组件 A 肯定是会被渲染两次的。要想避免第二次渲染，此时 React.pureComponent 就其作用了。这就是为什么说 React.pureComponent 可以减少 diff 次数。类似的原理，这也是为什么 shouldComponentUpdate 也可以减少 diff 次数 (_data:2021-2-10_)

### 生命周期

为啥要生命周期？ 这个问题是我初学 react 时候最为疑惑的问题。到现在，也是我不断思考的问题。
